from fastapi import FastAPI, Depends, HTTPException, status
from fastapi.middleware.cors import CORSMiddleware
from sqlalchemy.orm import Session
from typing import Optional, List
import os

# Import Pydantic models for request/response
from pydantic import BaseModel

from .database.database import get_db, init_db
from .database.models import User, Conversation, Message
from .services.database_service import user_service, conversation_service, message_service
from .services.embedding_service import EmbeddingService
from .services.vector_store_service import VectorStoreService
from .services.chat_service import ChatService


# Request/Response models
class StartConversationRequest(BaseModel):
    user_id: str


class StartConversationResponse(BaseModel):
    conversation_id: str
    message: str


class SendMessageRequest(BaseModel):
    message: str
    selected_text: Optional[str] = None


class SendMessageResponse(BaseModel):
    response: str
    sources: List[str]


class GetConversationResponse(BaseModel):
    id: str
    title: str
    created_at: str
    updated_at: str


class MessageResponse(BaseModel):
    id: str
    conversation_id: str
    sender_type: str
    content: str
    timestamp: str
    metadata: dict


class GetMessagesResponse(BaseModel):
    messages: List[MessageResponse]


class LoginRequest(BaseModel):
    email: str
    password: str


class LoginResponse(BaseModel):
    access_token: str
    token_type: str


class RegisterRequest(BaseModel):
    email: str
    username: str
    password: str


class RegisterResponse(BaseModel):
    message: str

# Initialize services
embedding_service = EmbeddingService()
vector_store_service = VectorStoreService()
chat_service = ChatService()

# Create FastAPI app
app = FastAPI(
    title="RAG Chatbot API for AI Robotics Textbook",
    description="API for the Retrieval-Augmented Generation chatbot that allows users to ask questions about the AI Robotics textbook content",
    version="1.0.0"
)

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # In production, replace with specific origins
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Event handlers
@app.on_event("startup")
def on_startup():
    """Initialize database on startup"""
    init_db()
    print("Database initialized successfully")

# Health check endpoint
@app.get("/health")
async def health_check():
    """Health check endpoint"""
    return {"status": "healthy", "service": "chatbot-api"}

# Basic chat endpoint (without context)
@app.post("/api/v1/chat/start", response_model=StartConversationResponse)
async def start_conversation(request: StartConversationRequest, db: Session = Depends(get_db)):
    """Start a new conversation"""
    # Get user
    user = user_service.get_user_by_id(db, request.user_id)
    if not user:
        raise HTTPException(status_code=404, detail="User not found")

    # Create new conversation
    conversation = conversation_service.create_conversation(
        db=db,
        user_id=request.user_id,
        title="New Conversation"
    )

    return StartConversationResponse(
        conversation_id=conversation.id,
        message="New conversation started"
    )

@app.post("/api/v1/chat/{conversation_id}/message")
async def send_message(conversation_id: str, message: str, selected_text: Optional[str] = None):
    """Send a message to the chatbot"""
    # This is a simplified version - in a real implementation, we'd have proper request/response models
    # and proper dependency injection

    # Create user message
    user_message = message_service.create_message(
        db=None,  # We'll add dependency injection later
        conversation_id=conversation_id,
        sender_type="user",
        content=message,
        metadata={"selected_text": selected_text} if selected_text else {}
    )

    # Generate AI response (this would involve calling the chat service with RAG)
    ai_response = "This is a placeholder response. In the full implementation, this would be generated by the AI model with RAG."

    # Create AI message
    ai_message = message_service.create_message(
        db=None,  # We'll add dependency injection later
        conversation_id=conversation_id,
        sender_type="assistant",
        content=ai_response
    )

    return {
        "response": ai_response,
        "sources": []  # In full implementation, this would contain source documents
    }

# Context-aware chat endpoint
@app.post("/api/v1/chat/{conversation_id}/context-message")
async def send_context_message(conversation_id: str, message: str, selected_text: str):
    """Send a message with selected text context to the chatbot"""
    # This endpoint specifically handles messages with selected text context
    return await send_message(conversation_id, message, selected_text)

# Get conversation details
@app.get("/api/v1/chat/{conversation_id}")
async def get_conversation(conversation_id: str):
    """Get conversation details"""
    conversation = conversation_service.get_conversation_by_id(
        db=None,  # We'll add dependency injection later
        conversation_id=conversation_id
    )

    if not conversation:
        raise HTTPException(status_code=404, detail="Conversation not found")

    return {
        "id": conversation.id,
        "title": conversation.title,
        "created_at": conversation.created_at,
        "updated_at": conversation.updated_at
    }

# Get messages in conversation
@app.get("/api/v1/chat/{conversation_id}/messages")
async def get_messages(conversation_id: str):
    """Get all messages in a conversation"""
    messages = message_service.get_messages_by_conversation(
        db=None,  # We'll add dependency injection later
        conversation_id=conversation_id
    )

    return {"messages": [
        {
            "id": msg.id,
            "conversation_id": msg.conversation_id,
            "sender_type": msg.sender_type,
            "content": msg.content,
            "timestamp": msg.timestamp,
            "metadata": msg.metadata
        }
        for msg in messages
    ]}

# Document processing endpoints
@app.get("/api/v1/documents/")
async def list_documents():
    """List all processed documents"""
    # This would be implemented with document_service
    return {"documents": []}

@app.post("/api/v1/documents/refresh")
async def refresh_documents():
    """Process all source documents and update embeddings in the vector store"""
    # This would be implemented with document_service and vector_store_service
    return {
        "message": "Document refresh process started",
        "document_count": 0
    }

# Authentication endpoints (simplified)
@app.post("/api/v1/auth/login")
async def login(email: str, password: str):
    """User login"""
    # This would be implemented with proper authentication
    return {
        "access_token": "fake-jwt-token",
        "token_type": "bearer"
    }

@app.post("/api/v1/auth/register")
async def register(email: str, username: str, password: str):
    """User registration"""
    # This would be implemented with proper registration logic
    return {"message": "User registered successfully"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)